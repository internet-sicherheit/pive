{# Copyright (c) 2019 - 2020, Tobias Stratmann                                  #}
{# All rights reserved.                                                         #}
{#                                                                              #}
{# Redistribution and use in source and binary forms, with or without           #}
{# modification, are permitted provided that the following conditions are met:  #}
{#                                                                              #}
{# 1. Redistributions of source code must retain the above copyright notice,    #}
{# this list of conditions and the following disclaimer.                        #}
{#                                                                              #}
{# 2. Redistributions in binary form must reproduce the above copyright notice, #}
{# this list of conditions and the following disclaimer in the documentation    #}
{# and/or other materials provided with the distribution.                       #}
{#                                                                              #}
{# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  #}
{# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    #}
{# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   #}
{# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE    #}
{# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR          #}
{# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         #}
{# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS     #}
{# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      #}
{# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)      #}
{# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   #}
{# POSSIBILITY OF SUCH DAMAGE.                                                  #}

//Created with pive {{ t_pive_version }} - the python interactive visualization environment.
//Visit https://github.com/daboth/pive for more information.

var width = "{{ t_width }}"
var height = "{{ t_height }}"
var map_shape = "{{ t_shape }}";
var inner_shape = "{{ t_inner }}";
var city = "{{ t_city }}"
var scale = {{ t_scale }};
var scaleExtent = {{  t_scale_extent }};
var transExtent = [[0,0],[width,height]];
var zoom_threshold = {{ t_zoom_threshold }};
var div_hook_map = "{{ t_div_hook_map }}";
var div_hook_tooltip = "{{ t_div_hook_tooltip }}";
var tooltip_div_border = "{{ t_tooltip_div_border }}";
var map_fill = "{{ t_map_fill }}";
var map_stroke = "{{ t_map_stroke }}";
var fill_opacity = {{ t_fill_opacity }};
var stroke_opacity = {{ t_stroke_opacity }};
var mouseover_opacity = {{ t_mouseover_opacity }};
var mouseout_opacity = {{ t_mouseout_opacity }};
var outer_map_fill = "{{ t_outer_map_fill }}";
var fontsize = 12; {# TODO: Set dynamically #}
var moveAmount = 20; {# TODO: Set dynamically #}


var hashtag = "#";
var hash_div_hook_map = hashtag.concat(div_hook_map);

var root_div_hook_map = document.getElementById(div_hook_map);
var root_div_hook_tooltip = document.getElementById(div_hook_tooltip);


{# JavaScript String is immutable, so single strings are defined for readability. #}
var css_pan_zoom_rect = "#{{ t_div_hook_map }} .pan rect, .zoom rect { fill: black; opacity: 0.2; }\n",
    css_pan_zoom_text = "#{{ t_div_hook_map }} .pan text, .zoom text { fill: black; font-size: 18px; text-anchor: middle; }\n",
    css_pan_zoom_hover = "#{{ t_div_hook_map }} .pan:hover rect, .pan:hover text, .zoom:hover rect, .zoom:hover text { fill:blue; }\n",
    css_text_label = "#{{ t_div_hook_map }} .label { font-family: Helvetica, sans-serif; text-anchor: middle; fill: black; }\n",
    css_tooltip = "#{{ t_div_hook_tooltip }} { font-family: Helvetica, sans-serif; margin-top: 10px; padding: 5px; white-space: pre-wrap; width: 590px; }\n";

{# The style definitions are concatinated into a single string. #}
var css = css_pan_zoom_rect.concat(css_pan_zoom_text).concat(css_pan_zoom_hover).concat(css_text_label).concat(css_tooltip);

{# The style element in the dom is created and included into the root div. #}
var style = document.createElement("style");
style.type = "text/css";
style.appendChild(document.createTextNode(css));
root_div_hook_map.appendChild(style);



// Svg, map, path, projection and zooming
var svg;
var map;
var path;
var projection;
var zoom;


// Configure the map
configMap();

// Determine and execute the method for visualization
visualize(map_shape, inner_shape);


// Set up the map
// Parameters: Scale factor for zooming, translate extent for panning borders and translate value for starting viewpoint
function configMap() {
    // Define map projection
    projection = d3.geoMercator();

    // Define path generator
    path = d3.geoPath()
        .projection(projection);

    // Create SVG element
    svg = d3.select(hash_div_hook_map)
        .append("svg")
        .attr("width", width)
        .attr("height", height);

    // Then define the zoom behavior
    zoom = d3.zoom()
        .scaleExtent(scaleExtent)
        .translateExtent(transExtent)
        .on("zoom", function (d) {
                map.selectAll("path").attr("transform", "translate(" + d3.event.transform.x + "," + d3.event.transform.y + ") scale(" + d3.event.transform.k + ")");
                map.selectAll("text").attr("transform", "translate(" + d3.event.transform.x + "," + d3.event.transform.y + ") scale(" + d3.event.transform.k + ")");
                map.selectAll("text").attr("font-size", fontsize/d3.event.transform.k);
            })


    // Create a container in which all pan-able elements will live
    map = svg.append("g")
        .attr("id", "map")
        .call(zoom);


    // Create a new, invisible background rect to catch drag events
    map.append("rect")
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", width)
        .attr("height", height)
        .attr("opacity", 0);
}

function vizPolygon(json_file, inner_shape) {

    outer_map = map.append("g")
        .attr("id", "outer_map")

    inner_map = map.append("g")
        .attr("id", "inner_map")

    // Load in GeoJSON data
    d3.json(json_file, function(json) {

        projection.fitExtent([[width*0.1,height*0.1],[width*0.9,height*0.9]], json);

        // Bind data and create one path per GeoJSON feature
        outer_map.selectAll("path")
            .data(json.features)
            .enter()
            .append("path")
            .attr("class", "json_path")
            .attr("d", path)
            .style("fill", outer_map_fill)
            .style("stroke", map_stroke)
            .style("fill-opacity", fill_opacity)
            .style("stroke-opacity", stroke_opacity);

        // Create a label to display its name
        outer_map.selectAll("text")
            .data(json.features)
            .enter()
            .append("text")
            .attr("class", "label")
            .attr("x", function (d) {
                return path.centroid(d)[0];
            })
            .attr("y", function (d) {
                return path.centroid(d)[1];
            })
            .text(function (d) {
                if (d.properties.name) {
                    return d.properties.name;
                }
            });
        // Load in GeoJSON data
        // Must be inside the other d3.json call or inside a following Promise, otherwise the projection update gets lost in a race condition
        d3.json(inner_shape, function(inner_json) {

            // Bind data and create one path per GeoJSON feature
            inner_map.selectAll("path")
                .data(inner_json)
                .enter()
                .append("path")
                .attr("class", "json_path")
                .attr("d", path)
                .style("fill", map_fill)
                .style("stroke", map_stroke)
                .style("fill-opacity", fill_opacity)
                .style("stroke-opacity", stroke_opacity)
                // Increase opacity while hovering over a polygon
                .on("mouseover", function() {
                    d3.select(this).style("fill-opacity", mouseover_opacity);
                })
                .on("mouseout", function() {
                    d3.select(this).style("fill-opacity", mouseout_opacity);
                })
                .on("click", function(d) {
                    var header = getHeader(d.properties);
                    showTooltip(d.properties, header);
                });
            });

    });

}

// Determine method for visualization
// Parameters: Selected file, GeoJSON files and visualization type
function visualize(json_file, inner_shape) {

    vizPolygon(json_file, inner_shape);

    // Call functions to initialize pan and zoom buttons
    createPanButtons();
    createZoomButtons();
}

// Read CSV header to check if columns for lat and lon data exist
// Parameters: Header of CSV
function getLatLon(header) {
    var latLon = [];
    var lat = ["Latitude", "Lat"];
    var latLC = [];
    var lon = ["Longitude", "Lon"];
    var lonLC = [];

    for(i = 0; i < lat.length; i++) {
        var name = lat[i].toLowerCase();
        latLC.push(name);
    }

    for(i = 0; i < lon.length; i++) {
        var name = lon[i].toLowerCase();
        lonLC.push(name);
    }
    
    for(i = 0; i < header.length; i++) {
        var columnName = header[i];
        if(latLC.includes(columnName.toLowerCase())) {
            latLon.push(columnName);
            break;
        }
    }
    
    for(i = 0; i < header.length; i++) {
        var columnName = header[i];
        if(lonLC.includes(columnName.toLowerCase())) {
            latLon.push(columnName);
            break;
        }
    }

    return latLon;
}

// Create pan buttons
function createPanButtons() {

    //Create the clickable groups

    //North
    var north = svg.append("g")
        .attr("class", "pan")   //All share the 'pan' class
        .attr("id", "north");   //The ID will tell us which direction to head   

    north.append("rect")
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", width)
        .attr("height", 30);

    north.append("text")
        .attr("x", width / 2)
        .attr("y", 20)
        .html("&uarr;");

    //South
    var south = svg.append("g")
        .attr("class", "pan")
        .attr("id", "south");

    south.append("rect")
        .attr("x", 0)
        .attr("y", height - 30)
        .attr("width", width)
        .attr("height", 30);

    south.append("text")
        .attr("x", width / 2)
        .attr("y", height - 10)
        .html("&darr;");

    //West
    var west = svg.append("g")
        .attr("class", "pan")
        .attr("id", "west");

    west.append("rect")
        .attr("x", 0)
        .attr("y", 30)
        .attr("width", 30)
        .attr("height", height - 60);

    west.append("text")
        .attr("x", 15)
        .attr("y", height / 2)
        .html("&larr;");

    //East
    var east = svg.append("g")
        .attr("class", "pan")
        .attr("id", "east");

    east.append("rect")
        .attr("x", width - 30)
        .attr("y", 30)
        .attr("width", 30)
        .attr("height", height - 60);

    east.append("text")
        .attr("x", width - 15)
        .attr("y", height / 2)
        .html("&rarr;");


    // Panning interaction

    d3.selectAll(".pan")
        .on("click", function () {

            // Set x/y to zero for now
            var x = 0;
            var y = 0;

            // Which way are we headed?
            var direction = d3.select(this).attr("id");

            // Modify the offset, depending on the direction
            switch (direction) {
                case "north":
                    y += moveAmount;
                    break;
                case "south":
                    y -= moveAmount;
                    break;
                case "west":
                    x += moveAmount;
                    break;
                case "east":
                    x -= moveAmount;
                    break;
                default:
                    break;
            }

            // This triggers a zoom event, translating by x, y
            map.transition()
                .call(zoom.translateBy, x, y);
        });
};

// Create zoom buttons
function createZoomButtons() {

    // Create the clickable groups

    // Zoom in button
    var zoomIn = svg.append("g")
        .attr("class", "zoom")
        .attr("id", "in")
        .attr("transform", "translate(" + (width - 110) + "," + (height - 70) + ")");

    zoomIn.append("rect")
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", 30)
        .attr("height", 30)
        .attr("rx", 5)
        .attr("ry", 5);

    zoomIn.append("text")
        .attr("x", 15)
        .attr("y", 20)
        .text("+");

    // Zoom out button
    var zoomOut = svg.append("g")
        .attr("class", "zoom")
        .attr("id", "out")
        .attr("transform", "translate(" + (width - 70) + "," + (height - 70) + ")");

    zoomOut.append("rect")
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", 30)
        .attr("height", 30)
        .attr("rx", 5)
        .attr("ry", 5);

    zoomOut.append("text")
        .attr("x", 15)
        .attr("y", 20)
        .html("&ndash;");

    // Zooming interaction
    d3.selectAll(".zoom")
        .on("click", function () {

            // Set how much to scale on each click
            var scaleFactor;

            // Which way are we headed?
            var direction = d3.select(this).attr("id");

            // Modify the k scale value, depending on the direction
            switch (direction) {
                case "in":
                    scaleFactor = 1.5;
                    break;
                case "out":
                    scaleFactor = 0.75;
                    break;
                default:
                    break;
            }

            // This triggers a zoom event, scaling by 'scaleFactor'
            map.transition()
                .call(zoom.scaleBy, scaleFactor);
        });
};

// Display tooltip for heatmap or POIs showing the explicit values
// Parameter: Selected district or point of interest to show tooltip for and header names
function showTooltip(data, header) {
    // Get column names for lat and lon data to hide these columns in the tooltip
    var latLon = getLatLon(header);
    var lat = latLon[0];
    var lon = latLon[1];
    var div = root_div_hook_tooltip;
    var text = "";

    for(i = 0; i < header.length; i++) {
        var name = header[i];
        if(name != lat && name != lon && name != "id") {
            var value = data[name];
            if(text) {
                text = text + "\n" + name + ": " + value;
            } else {
                text = name + ": " + value;
            }  
        }
    }
    if(div.innerHTML != text) {
        div.style.border = tooltip_div_border;
        div.innerHTML = text;
    } else {
        div.style.border = "none";
        div.innerHTML = "";
    }
}

// Access data to get column names/names of properties
// Parameter: Data of CSV or JSON file
function getHeader(data) {
    var header = [];
    
    for(var key in data) {
        if(Array.isArray(data)) {
            header.push(data[key]);
        } else {
            header.push(key);
        }
        
    }

    return header;
}
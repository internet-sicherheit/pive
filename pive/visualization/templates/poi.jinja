{# Copyright (c) 2019 - 2020, Tobias Stratmann                                  #}
{# All rights reserved.                                                         #}
{#                                                                              #}
{# Redistribution and use in source and binary forms, with or without           #}
{# modification, are permitted provided that the following conditions are met:  #}
{#                                                                              #}
{# 1. Redistributions of source code must retain the above copyright notice,    #}
{# this list of conditions and the following disclaimer.                        #}
{#                                                                              #}
{# 2. Redistributions in binary form must reproduce the above copyright notice, #}
{# this list of conditions and the following disclaimer in the documentation    #}
{# and/or other materials provided with the distribution.                       #}
{#                                                                              #}
{# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  #}
{# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    #}
{# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   #}
{# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE    #}
{# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR          #}
{# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         #}
{# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS     #}
{# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      #}
{# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)      #}
{# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   #}
{# POSSIBILITY OF SUCH DAMAGE.                                                  #}

//Created with pive {{ t_pive_version }} - the python interactive visualization environment.
//Visit https://github.com/daboth/pive for more information.

var width = "{{ t_width }}"
var height = "{{ t_height }}"
var filename = "../{{ t_filename }}";
var map_shape = "{{ t_shape }}";
var city = "{{ t_city }}";
var scale = {{ t_scale }};
var scaleExtent = {{ t_scale_extent }};
var scaleAdjust = {{ t_scale_adjust }};
var transExtent = {{ t_trans_extent }};
var xTranslate = {{ t_x_translate }};
var yTranslate = {{ t_y_translate }};
var zoom_threshold = {{ t_zoom_threshold }};
var div_hook_map = "{{ t_div_hook_map }}";
var div_hook_tooltip = "{{ t_div_hook_tooltip }}";
var tooltip_div_border = "{{ t_tooltip_div_border }}";
var map_fill = "{{ t_map_fill }}";
var map_stroke = "{{ t_map_stroke }}";
var fill_opacity = {{ t_fill_opacity }};
var stroke_opacity = {{ t_stroke_opacity }};
var mouseover_opacity = {{ t_mouseover_opacity }};
var mouseout_opacity = {{ t_mouseout_opacity }};
var circle_fill = "{{ t_circle_fill }}";
var circle_stroke = "{{ t_circle_stroke }}";
var circle_radius = {{ t_circle_radius }};
var circle_stroke_width = {{ t_circle_stroke_width }};
var max_poi = {{ t_max_poi }};
var file_extension = "{{ t_file_extension }}";


var hashtag = "#";
var hash_div_hook_map = hashtag.concat(div_hook_map);

var root_div_hook_map = document.getElementById(div_hook_map);
var root_div_hook_tooltip = document.getElementById(div_hook_tooltip);


{# JavaScript String is immutable, so single strings are defined for readability. #}
var css_pan_zoom_rect = "#{{ t_div_hook_map }} .pan rect, .zoom rect { fill: black; opacity: 0.2; }\n",
    css_pan_zoom_text = "#{{ t_div_hook_map }} .pan text, .zoom text { fill: black; font-size: 18px; text-anchor: middle; }\n",
    css_pan_zoom_hover = "#{{ t_div_hook_map }} .pan:hover rect, .pan:hover text, .zoom:hover rect, .zoom:hover text { fill:blue; }\n",
    css_text_label = "#{{ t_div_hook_map }} .label { font-family: Helvetica, sans-serif; font-size: 8px; text-anchor: middle; fill: black; }\n",
    css_tooltip = "#{{ t_div_hook_tooltip }} { font-family: Helvetica, sans-serif; margin-top: 10px; padding: 5px; white-space: pre-wrap; width: 590px; }\n";

{# The style definitions are concatinated into a single string. #}
var css = css_pan_zoom_rect.concat(css_pan_zoom_text).concat(css_pan_zoom_hover).concat(css_text_label).concat(css_tooltip);

{# The style element in the dom is created and included into the root div. #}
var style = document.createElement("style");
style.type = "text/css";
style.appendChild(document.createTextNode(css));
root_div_hook_map.appendChild(style);



// Svg, map, path, projection and zooming
var svg;
var map;
var path;
var projection;
var zoom;


// Configure the map
configMap(scaleAdjust, transExtent, xTranslate, yTranslate);            

// Determine and execute the method for visualization
visualize(filename, map_shape);


// Set up the map
// Parameters: Scale factor for zooming, translate extent for panning borders and translate value for starting viewpoint
function configMap(scaleAdjust, transExtent, xTranslate, yTranslate) {
    // Define map projection
    projection = d3.geoMercator()
        .translate([0, 0]);

    // Define path generator
    path = d3.geoPath()
        .projection(projection);

    // Create SVG element
    svg = d3.select(hash_div_hook_map)
        .append("svg")
        .attr("width", width)
        .attr("height", height);

    // Define what to do when panning or zooming
    var zooming = function(d) {
        // Column names for lat and lon data
        var lat;
        var lon;

        // New offset array
        var offset = [d3.event.transform.x, d3.event.transform.y];

        // Calculate new scale
        var newScale = d3.event.transform.k * scaleAdjust;

        // Update projection with new offset
        projection.translate(offset)
            .scale(newScale);

        // Update all paths and labels
        svg.selectAll("path")
            .attr("d", path);
        svg.selectAll(".label")
            .attr("x", function(d) {
                return path.centroid(d)[0];
            })
            .attr("y", function(d) {
                return path.centroid(d)[1];
            })
            // Bind font-size to zoom-level
            .style("font-size", function() {
                var size = d3.event.transform.k;
                if(size >= zoom_threshold) {
                    size = size / 2;
                }
                return size + "px";
            })
            // While zoomed out display district id rather than the full name
            .text(function(d) {
                var zoomLevel = d3.event.transform.k;
                if(zoomLevel < zoom_threshold) {
                    return d.properties.id;
                } else {
                    return d.properties.name;
                }
            })
        svg.selectAll("circle")
            .attr("cx", function (d) {
                if(file_extension == ".csv") {
                    // Need Json header method to read d
                    var header = getHeader(d);
                    // Read column names for lat and lon data
                    var latLon = getLatLon(header);
                    lat = latLon[0];
                    lon = latLon[1];
                    return projection([d[lon], d[lat]])[0];
                } else if(file_extension == ".json") {
                    return projection(d.geometry.coordinates)[0];
                }
            })
        svg.selectAll("circle")
            .attr("cy", function (d) {
                if(file_extension == ".csv") {
                    return projection([d[lon], d[lat]])[1];
                } else if(file_extension == ".json") {
                    return projection(d.geometry.coordinates)[1];
                }
            })
    }

    // Then define the zoom behavior
    zoom = d3.zoom()
        .scaleExtent(scaleExtent)
        .translateExtent(transExtent)
        .on("zoom", zooming);

    // The center of the country, roughly
    var center = projection([0, 0]);

    // Create a container in which all pan-able elements will live
    map = svg.append("g")
        .attr("id", "map")
        .call(zoom)   // Bind the zoom behaviour
        .call(zoom.transform, d3.zoomIdentity  // Then apply the initial transform
            .translate(xTranslate, yTranslate)
            .scale(scale)
            .translate(-center[0], -center[1]));


    // Create a new, invisible background rect to catch drag events
    map.append("rect")
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", width)
        .attr("height", height)
        .attr("opacity", 0);
}


// Visualize points of interest
// Parameters: Selected file and GeoJSON file
function vizPoi(filename, json_file) {
    // Load in GeoJSON data
    d3.json(json_file, function(json) {

        // Bind data and create one path per GeoJSON feature
        map.selectAll("path")
            .data(json.features)
            .enter()
            .append("path")
            .attr("class", "json_path")
            .attr("d", path)
            .style("fill", map_fill)
            .style("stroke", map_stroke)
            .style("fill-opacity", fill_opacity)
            .style("stroke-opacity", stroke_opacity)

        // Create a label to display its name
        map.selectAll("text")
            .data(json.features)
            .enter()
            .append("text")
            .attr("class", "label")
            .attr("x", function (d) {
                return path.centroid(d)[0];
            })
            .attr("y", function (d) {
                return path.centroid(d)[1];
            })
            .text(function (d) {
                if (d.properties.name) {
                    return d.properties.name;
                }
            })

        if(file_extension == ".csv") {
            poiFromCsv(filename);
        } else if(file_extension == ".json") {
            poiFromJson(filename);
        }
    });
}


// Visualize points of interest from CSV
// Parameters: CSV file
function poiFromCsv(filename) {
    // Load in CSV data
    d3.csv(filename, function(data) {
        // Store points of interest
        var poi = [];

        // Read header from CSV
        var header = getHeader(data.columns);
        // Read column names for lat and lon data
        var latLon = getLatLon(header);
        var lat = latLon[0];
        var lon = latLon[1];

        // Only a set amount of Points of interest
        if(max_poi) {
            for(i = 0; i < max_poi && i < data.length; i++) {
                poi.push(data[i]);
            }
        } else {
            poi = data;
        }
        
        // Bind data and create one circle per point of interest
        map.selectAll("circle")
            .data(poi)
            .enter()
            .append("circle")
            .attr("cx", function (d) {
                return projection([d[lon], d[lat]])[0];
            })
            .attr("cy", function (d) {
                return projection([d[lon], d[lat]])[1];
            })
            .attr("r", circle_radius)
            .style("fill", circle_fill)
            .style("stroke", circle_stroke)
            .style("stroke-width", circle_stroke_width)
            .style("fill-opacity", fill_opacity)
            // Increase opacity while hovering over a point of interest, and show a tooltip after clicking it
            .on("mouseover", function() {
                d3.select(this).style("fill-opacity", mouseover_opacity);
            })
            .on("mouseout", function() {
                d3.select(this).style("fill-opacity", mouseout_opacity);
            })
            .on("click", function(d) {
                // Show tooltip
                showTooltip(d, header);
            });
    });
}

// Visualize points of interest from JSON
// Parameters: JSON file
function poiFromJson(filename) {
    // Load in JSON data with POI
    d3.json(filename, function(data) {
        // Store points of interest
        var poi = [];

        // Only a set amount of Points of Interest
        if(max_poi) {
            for(i = 0; i < max_poi && i < data.features.length; i++) {
                poi.push(data.features[i]);
            }
        } else {
            poi = data;
        }                

        // Bind data and create one circle per point of interest
        map.selectAll("circle")
            .data(poi)
            .enter()
            .append("circle")
            .attr("cx", function (d) {
                return projection(d.geometry.coordinates)[0];
            })
            .attr("cy", function (d) {
                return projection(d.geometry.coordinates)[1];
            })
            .attr("r", circle_radius)
            .style("fill", circle_fill)
            .style("stroke", circle_stroke)
            .style("stroke-width", circle_stroke_width)
            .style("fill-opacity", fill_opacity)
            // Increase opacity while hovering over a point of interest, and show a tooltip after clicking it
            .on("mouseover", function() {
                d3.select(this).style("fill-opacity", mouseover_opacity);
            })
            .on("mouseout", function() {
                d3.select(this).style("fill-opacity", mouseout_opacity);
            })
            .on("click", function(d) {
                // Read header from JSON
                var header = getHeader(d.properties);
                // Show tooltip
                showTooltip(d.properties, header);
            });
    });
}

// Determine method for visualization
// Parameters: Selected file, GeoJSON files and visualization type
function visualize(filename, json_file) {

    vizPoi(filename, json_file);

    // Call functions to initialize pan and zoom buttons
    createPanButtons();
    createZoomButtons();
}

// Read CSV header to check if columns for lat and lon data exist
// Parameters: Header of CSV
function getLatLon(header) {
    var latLon = [];
    var lat = ["Latitude", "Lat"];
    var latLC = [];
    var lon = ["Longitude", "Lon"];
    var lonLC = [];

    for(i = 0; i < lat.length; i++) {
        var name = lat[i].toLowerCase();
        latLC.push(name);
    }

    for(i = 0; i < lon.length; i++) {
        var name = lon[i].toLowerCase();
        lonLC.push(name);
    }
    
    for(i = 0; i < header.length; i++) {
        var columnName = header[i];
        if(latLC.includes(columnName.toLowerCase())) {
            latLon.push(columnName);
            break;
        }
    }
    
    for(i = 0; i < header.length; i++) {
        var columnName = header[i];
        if(lonLC.includes(columnName.toLowerCase())) {
            latLon.push(columnName);
            break;
        }
    }

    return latLon;
}

// Create pan buttons
function createPanButtons() {

    //Create the clickable groups

    //North
    var north = svg.append("g")
        .attr("class", "pan")   //All share the 'pan' class
        .attr("id", "north");   //The ID will tell us which direction to head   

    north.append("rect")
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", width)
        .attr("height", 30);

    north.append("text")
        .attr("x", width / 2)
        .attr("y", 20)
        .html("&uarr;");

    //South
    var south = svg.append("g")
        .attr("class", "pan")
        .attr("id", "south");

    south.append("rect")
        .attr("x", 0)
        .attr("y", height - 30)
        .attr("width", width)
        .attr("height", 30);

    south.append("text")
        .attr("x", width / 2)
        .attr("y", height - 10)
        .html("&darr;");

    //West
    var west = svg.append("g")
        .attr("class", "pan")
        .attr("id", "west");

    west.append("rect")
        .attr("x", 0)
        .attr("y", 30)
        .attr("width", 30)
        .attr("height", height - 60);

    west.append("text")
        .attr("x", 15)
        .attr("y", height / 2)
        .html("&larr;");

    //East
    var east = svg.append("g")
        .attr("class", "pan")
        .attr("id", "east");

    east.append("rect")
        .attr("x", width - 30)
        .attr("y", 30)
        .attr("width", 30)
        .attr("height", height - 60);

    east.append("text")
        .attr("x", width - 15)
        .attr("y", height / 2)
        .html("&rarr;");


    // Panning interaction

    d3.selectAll(".pan")
        .on("click", function () {

            // Set how much to move on each click
            var moveAmount = 1;

            // Set x/y to zero for now
            var x = 0;
            var y = 0;

            // Which way are we headed?
            var direction = d3.select(this).attr("id");

            // Modify the offset, depending on the direction
            switch (direction) {
                case "north":
                    y += moveAmount;
                    break;
                case "south":
                    y -= moveAmount;
                    break;
                case "west":
                    x += moveAmount;
                    break;
                case "east":
                    x -= moveAmount;
                    break;
                default:
                    break;
            }

            // This triggers a zoom event, translating by x, y
            map.transition()
                .call(zoom.translateBy, x, y);
        });
};

// Create zoom buttons
function createZoomButtons() {

    // Create the clickable groups

    // Zoom in button
    var zoomIn = svg.append("g")
        .attr("class", "zoom")
        .attr("id", "in")
        .attr("transform", "translate(" + (width - 110) + "," + (height - 70) + ")");

    zoomIn.append("rect")
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", 30)
        .attr("height", 30)
        .attr("rx", 5)
        .attr("ry", 5);

    zoomIn.append("text")
        .attr("x", 15)
        .attr("y", 20)
        .text("+");

    // Zoom out button
    var zoomOut = svg.append("g")
        .attr("class", "zoom")
        .attr("id", "out")
        .attr("transform", "translate(" + (width - 70) + "," + (height - 70) + ")");

    zoomOut.append("rect")
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", 30)
        .attr("height", 30)
        .attr("rx", 5)
        .attr("ry", 5);

    zoomOut.append("text")
        .attr("x", 15)
        .attr("y", 20)
        .html("&ndash;");

    // Zooming interaction
    d3.selectAll(".zoom")
        .on("click", function () {

            // Set how much to scale on each click
            var scaleFactor;

            // Which way are we headed?
            var direction = d3.select(this).attr("id");

            // Modify the k scale value, depending on the direction
            switch (direction) {
                case "in":
                    scaleFactor = 1.5;
                    break;
                case "out":
                    scaleFactor = 0.75;
                    break;
                default:
                    break;
            }

            // This triggers a zoom event, scaling by 'scaleFactor'
            map.transition()
                .call(zoom.scaleBy, scaleFactor);
        });
};

// Display tooltip for heatmap or POIs showing the explicit values
// Parameter: Selected district or point of interest to show tooltip for and header names
function showTooltip(data, header) {
    // Get column names for lat and lon data to hide these columns in the tooltip
    var latLon = getLatLon(header);
    var lat = latLon[0];
    var lon = latLon[1];
    var div = root_div_hook_tooltip;
    var text = "";

    for(i = 0; i < header.length; i++) {
        var name = header[i];
        if(name != lat && name != lon && name != "id") {
            var value = data[name];
            if(text) {
                text = text + "\n" + name + ": " + value;
            } else {
                text = name + ": " + value;
            }  
        }
    }
    if(div.innerHTML != text) {
        div.style.border = tooltip_div_border;
        div.innerHTML = text;
    } else {
        div.style.border = "none";
        div.innerHTML = "";
    }
}

// Access data to get column names/names of properties
// Parameter: Data of CSV or JSON file
function getHeader(data) {
    var header = [];
    
    for(var key in data) {
        if(Array.isArray(data)) {
            header.push(data[key]);
        } else {
            header.push(key);
        }
        
    }

    return header;
}